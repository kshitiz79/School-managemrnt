{
    "sourceFile": "src/lib/api.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1755987434757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1755987453184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,4 @@\n-import mockData from './mockData.js'\n \n // Simulate network latency\n const delay = (ms = 500 + Math.random() * 1000) =>\n     new Promise(resolve => setTimeout(resolve, ms))\n"
                },
                {
                    "date": 1755987712179,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,654 +1,657 @@\n+import mockData from './mockData.js'\n \n // Simulate network latency\n const delay = (ms = 500 + Math.random() * 1000) =>\n-    new Promise(resolve => setTimeout(resolve, ms))\n+  new Promise(resolve => setTimeout(resolve, ms))\n \n // Simulate API errors occasionally\n const shouldSimulateError = (errorRate = 0.05) => Math.random() < errorRate\n \n const createError = (status, message) => {\n-    const error = new Error(message)\n-    error.status = status\n-    return error\n+  const error = new Error(message)\n+  error.status = status\n+  return error\n }\n \n // Generic CRUD operations\n const createCrudApi = (resourceName, data) => ({\n-    getAll: async(filters = {}) => {\n-        await delay()\n-        if (shouldSimulateError()) {\n-            throw createError(500, `Failed to fetch ${resourceName}`)\n-        }\n+  getAll: async (filters = {}) => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, `Failed to fetch ${resourceName}`)\n+    }\n \n-        let result = [...data]\n+    let result = [...data]\n \n-        // Apply filters\n-        Object.entries(filters).forEach(([key, value]) => {\n-            if (value !== undefined && value !== null && value !== '') {\n-                result = result.filter(item => {\n-                    if (typeof item[key] === 'string') {\n-                        return item[key].toLowerCase().includes(value.toLowerCase())\n-                    }\n-                    return item[key] === value\n-                })\n-            }\n+    // Apply filters\n+    Object.entries(filters).forEach(([key, value]) => {\n+      if (value !== undefined && value !== null && value !== '') {\n+        result = result.filter(item => {\n+          if (typeof item[key] === 'string') {\n+            return item[key].toLowerCase().includes(value.toLowerCase())\n+          }\n+          return item[key] === value\n         })\n+      }\n+    })\n \n-        return result\n-    },\n+    return result\n+  },\n \n-    getById: async id => {\n-        await delay()\n-        if (shouldSimulateError()) {\n-            throw createError(500, `Failed to fetch ${resourceName}`)\n-        }\n+  getById: async id => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, `Failed to fetch ${resourceName}`)\n+    }\n \n-        const item = data.find(item => item.id === id)\n-        if (!item) {\n-            throw createError(404, `${resourceName} not found`)\n-        }\n+    const item = data.find(item => item.id === id)\n+    if (!item) {\n+      throw createError(404, `${resourceName} not found`)\n+    }\n \n-        return item\n-    },\n+    return item\n+  },\n \n-    create: async newItem => {\n-        await delay()\n-        if (shouldSimulateError()) {\n-            throw createError(500, `Failed to create ${resourceName}`)\n-        }\n+  create: async newItem => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, `Failed to create ${resourceName}`)\n+    }\n \n-        const item = {\n-            ...newItem,\n-            id: `${resourceName}-${Date.now()}`,\n-            createdAt: new Date().toISOString(),\n-            updatedAt: new Date().toISOString(),\n-        }\n+    const item = {\n+      ...newItem,\n+      id: `${resourceName}-${Date.now()}`,\n+      createdAt: new Date().toISOString(),\n+      updatedAt: new Date().toISOString(),\n+    }\n \n-        data.push(item)\n-        return item\n-    },\n+    data.push(item)\n+    return item\n+  },\n \n-    update: async(id, updates) => {\n-        await delay()\n-        if (shouldSimulateError()) {\n-            throw createError(500, `Failed to update ${resourceName}`)\n-        }\n+  update: async (id, updates) => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, `Failed to update ${resourceName}`)\n+    }\n \n-        const index = data.findIndex(item => item.id === id)\n-        if (index === -1) {\n-            throw createError(404, `${resourceName} not found`)\n-        }\n+    const index = data.findIndex(item => item.id === id)\n+    if (index === -1) {\n+      throw createError(404, `${resourceName} not found`)\n+    }\n \n-        data[index] = {\n-            ...data[index],\n-            ...updates,\n-            updatedAt: new Date().toISOString(),\n-        }\n+    data[index] = {\n+      ...data[index],\n+      ...updates,\n+      updatedAt: new Date().toISOString(),\n+    }\n \n-        return data[index]\n-    },\n+    return data[index]\n+  },\n \n-    delete: async id => {\n-        await delay()\n-        if (shouldSimulateError()) {\n-            throw createError(500, `Failed to delete ${resourceName}`)\n-        }\n+  delete: async id => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, `Failed to delete ${resourceName}`)\n+    }\n \n-        const index = data.findIndex(item => item.id === id)\n-        if (index === -1) {\n-            throw createError(404, `${resourceName} not found`)\n-        }\n+    const index = data.findIndex(item => item.id === id)\n+    if (index === -1) {\n+      throw createError(404, `${resourceName} not found`)\n+    }\n \n-        const deleted = data.splice(index, 1)[0]\n-        return deleted\n-    },\n+    const deleted = data.splice(index, 1)[0]\n+    return deleted\n+  },\n })\n \n // Students API\n export const studentsApi = {\n-    ...createCrudApi('student', mockData.students),\n+  ...createCrudApi('student', mockData.students),\n \n-    getByClass: async(classId, section) => {\n-        await delay()\n-        if (shouldSimulateError()) {\n-            throw createError(500, 'Failed to fetch students by class')\n-        }\n+  getByClass: async (classId, section) => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, 'Failed to fetch students by class')\n+    }\n \n-        return mockData.students.filter(\n-            student =>\n-            student.classId === classId && (!section || student.section === section),\n-        )\n-    },\n+    return mockData.students.filter(\n+      student =>\n+        student.classId === classId && (!section || student.section === section),\n+    )\n+  },\n \n-    getByParent: async parentEmail => {\n-        await delay()\n-        return mockData.students.filter(\n-            student => student.parentEmail === parentEmail,\n-        )\n-    },\n+  getByParent: async parentEmail => {\n+    await delay()\n+    return mockData.students.filter(\n+      student => student.parentEmail === parentEmail,\n+    )\n+  },\n }\n \n // Staff API\n export const staffApi = {\n-    ...createCrudApi('staff', mockData.staff),\n+  ...createCrudApi('staff', mockData.staff),\n \n-    getTeachers: async() => {\n-        await delay()\n-        return mockData.staff.filter(member => member.role === 'teacher')\n-    },\n+  getTeachers: async () => {\n+    await delay()\n+    return mockData.staff.filter(member => member.role === 'teacher')\n+  },\n \n-    getByDepartment: async department => {\n-        await delay()\n-        return mockData.staff.filter(member => member.department === department)\n-    },\n+  getByDepartment: async department => {\n+    await delay()\n+    return mockData.staff.filter(member => member.department === department)\n+  },\n }\n \n // Classes API\n export const classesApi = {\n-    ...createCrudApi('class', mockData.classes),\n+  ...createCrudApi('class', mockData.classes),\n \n-    getSections: async classId => {\n-        await delay()\n-        const classData = mockData.classes.find(c => c.id === classId)\n-        if (!classData) {\n-            throw createError(404, 'Class not found')\n-        }\n+  getSections: async classId => {\n+    await delay()\n+    const classData = mockData.classes.find(c => c.id === classId)\n+    if (!classData) {\n+      throw createError(404, 'Class not found')\n+    }\n \n-        return classData.sections.map(section => ({\n-            id: `${classId}-${section}`,\n-            name: section,\n-            classId,\n-            students: mockData.students.filter(\n-                s => s.classId === classId && s.section === section,\n-            ).length,\n-        }))\n-    },\n+    return classData.sections.map(section => ({\n+      id: `${classId}-${section}`,\n+      name: section,\n+      classId,\n+      students: mockData.students.filter(\n+        s => s.classId === classId && s.section === section,\n+      ).length,\n+    }))\n+  },\n }\n \n // Subjects API\n export const subjectsApi = createCrudApi('subject', mockData.subjects)\n \n // Attendance API\n export const attendanceApi = {\n-    ...createCrudApi('attendance', mockData.attendance),\n+  ...createCrudApi('attendance', mockData.attendance),\n \n-    getByUser: async(userId, dateRange = {}) => {\n-        await delay()\n-        let records = mockData.attendance.filter(record => record.userId === userId)\n+  getByUser: async (userId, dateRange = {}) => {\n+    await delay()\n+    let records = mockData.attendance.filter(record => record.userId === userId)\n \n-        if (dateRange.start) {\n-            records = records.filter(record => record.date >= dateRange.start)\n-        }\n-        if (dateRange.end) {\n-            records = records.filter(record => record.date <= dateRange.end)\n-        }\n+    if (dateRange.start) {\n+      records = records.filter(record => record.date >= dateRange.start)\n+    }\n+    if (dateRange.end) {\n+      records = records.filter(record => record.date <= dateRange.end)\n+    }\n \n-        return records\n-    },\n+    return records\n+  },\n \n-    getByClass: async(classId, section, date) => {\n-        await delay()\n-        const students = mockData.students.filter(\n-            s => s.classId === classId && s.section === section,\n-        )\n+  getByClass: async (classId, section, date) => {\n+    await delay()\n+    const students = mockData.students.filter(\n+      s => s.classId === classId && s.section === section,\n+    )\n \n-        const attendanceRecords = mockData.attendance.filter(\n-            record => record.date === date && record.type === 'student',\n-        )\n+    const attendanceRecords = mockData.attendance.filter(\n+      record => record.date === date && record.type === 'student',\n+    )\n \n-        return students.map(student => {\n-            const record = attendanceRecords.find(r => r.userId === student.id)\n-            return {\n-                student,\n-                attendance: record || {\n-                    status: 'not_marked',\n-                    date,\n-                    userId: student.id,\n-                },\n-            }\n-        })\n-    },\n+    return students.map(student => {\n+      const record = attendanceRecords.find(r => r.userId === student.id)\n+      return {\n+        student,\n+        attendance: record || {\n+          status: 'not_marked',\n+          date,\n+          userId: student.id,\n+        },\n+      }\n+    })\n+  },\n \n-    getTodayAttendance: async() => {\n-        await delay()\n-        const today = new Date().toISOString().split('T')[0]\n+  getTodayAttendance: async () => {\n+    await delay()\n+    const today = new Date().toISOString().split('T')[0]\n \n-        const studentAttendance = mockData.attendance.filter(\n-            record => record.date === today && record.type === 'student',\n-        )\n+    const studentAttendance = mockData.attendance.filter(\n+      record => record.date === today && record.type === 'student',\n+    )\n \n-        const staffAttendance = mockData.attendance.filter(\n-            record => record.date === today && record.type === 'staff',\n-        )\n+    const staffAttendance = mockData.attendance.filter(\n+      record => record.date === today && record.type === 'staff',\n+    )\n \n-        const totalStudents = mockData.students.filter(\n-            s => s.status === 'active'\n-        ).length\n-        const totalStaff = mockData.staff.filter(s => s.status === 'active').length\n+    const totalStudents = mockData.students.filter(\n+      s => s.status === 'active'\n+    ).length\n+    const totalStaff = mockData.staff.filter(s => s.status === 'active').length\n \n-        const presentStudents = studentAttendance.filter(\n-            r => r.status === 'present'\n-        ).length\n-        const presentStaff = staffAttendance.filter(\n-            r => r.status === 'present'\n-        ).length\n+    const presentStudents = studentAttendance.filter(\n+      r => r.status === 'present'\n+    ).length\n+    const presentStaff = staffAttendance.filter(\n+      r => r.status === 'present'\n+    ).length\n \n-        return {\n-            students: {\n-                total: totalStudents,\n-                present: presentStudents,\n-                absent: totalStudents - presentStudents,\n-                percentage: totalStudents > 0 ?\n-                    ((presentStudents / totalStudents) * 100).toFixed(1) :\n-                    0,\n-            },\n-            staff: {\n-                total: totalStaff,\n-                present: presentStaff,\n-                absent: totalStaff - presentStaff,\n-                percentage: totalStaff > 0 ? ((presentStaff / totalStaff) * 100).toFixed(1) : 0,\n-            },\n-        }\n-    },\n+    return {\n+      students: {\n+        total: totalStudents,\n+        present: presentStudents,\n+        absent: totalStudents - presentStudents,\n+        percentage: totalStudents > 0 ?\n+          ((presentStudents / totalStudents) * 100).toFixed(1) : 0,\n+      },\n+      staff: {\n+        total: totalStaff,\n+        present: presentStaff,\n+        absent: totalStaff - presentStaff,\n+        percentage: totalStaff > 0 ? ((presentStaff / totalStaff) * 100).toFixed(1) : 0,\n+      },\n+    }\n+  },\n \n-    markAttendance: async attendanceData => {\n-        await delay()\n-        if (shouldSimulateError()) {\n-            throw createError(500, 'Failed to mark attendance')\n-        }\n+  markAttendance: async attendanceData => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, 'Failed to mark attendance')\n+    }\n \n-        const records = attendanceData.map(data => ({\n-            id: `att-${data.userId}-${data.date}`,\n-            ...data,\n-            markedAt: new Date().toISOString(),\n-        }))\n+    const records = attendanceData.map(data => ({\n+      id: `att-${data.userId}-${data.date}`,\n+      ...data,\n+      markedAt: new Date().toISOString(),\n+    }))\n \n-        // Remove existing records for the same date and users\n-        mockData.attendance = mockData.attendance.filter(\n-            record =>\n-            !attendanceData.some(\n-                data => data.userId === record.userId && data.date === record.date,\n-            )\n+    // Remove existing records for the same date and users\n+    mockData.attendance = mockData.attendance.filter(\n+      record =>\n+        !attendanceData.some(\n+          data => data.userId === record.userId && data.date === record.date,\n         )\n+    )\n \n-        mockData.attendance.push(...records)\n-        return records\n-    },\n+    mockData.attendance.push(...records)\n+    return records\n+  },\n }\n \n // Exams API\n export const examsApi = {\n-        ...createCrudApi('exam', mockData.exams),\n+  ...createCrudApi('exam', mockData.exams),\n \n-        getSchedule: async(classId, section) => {\n-            await delay()\n-            return mockData.exams.filter(\n-                exam => exam.classId === classId &&\n-                (!section || exam.section === section),\n-            )\n-        },\n+  getSchedule: async (classId, section) => {\n+    await delay()\n+    return mockData.exams.filter(\n+      exam => exam.classId === classId &&\n+        (!section || exam.section === section),\n+    )\n+  },\n \n-        getResults: async(examId, studentId) => {\n-            await delay()\n-            let results = mockData.examResults.filter(\n-                    result => result.examId === examId\n+  getResults: async (examId, studentId) => {\n+    await delay()\n+    let results = mockData.examResults.filter(\n+      result => result.examId === examId\n+    )\n \n-                    if (studentId) {\n-                        results = results.filter(result => result.studentId === studentId)\n-                    }\n+    if (studentId) {\n+      results = results.filter(result => result.studentId === studentId)\n+    }\n \n-                    return results\n-                },\n+    return results\n+  },\n \n-                submitResult: async resultData => {\n-                    await delay()\n-                    if (shouldSimulateError()) {\n-                        throw createError(500, 'Failed to submit result')\n-                    }\n+  submitResult: async resultData => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, 'Failed to submit result')\n+    }\n \n-                    const result = {\n-                        id: `result-${Date.now()}`,\n-                        ...resultData,\n-                        evaluatedAt: new Date().toISOString(),\n-                    }\n+    const result = {\n+      id: `result-${Date.now()}`,\n+      ...resultData,\n+      evaluatedAt: new Date().toISOString(),\n+    }\n \n-                    mockData.examResults.push(result)\n-                    return result\n-                },\n-        }\n+    mockData.examResults.push(result)\n+    return result\n+  },\n+}\n \n-        // Fees API\n-            export const feesApi = {\n-                    feeStructure: createCrudApi('fee-structure', mockData.feeStructure),\n-                    payments: createCrudApi('fee-payment', mockData.feePayments),\n+// Fees API\n+export const feesApi = {\n+  feeStructure: createCrudApi('fee-structure', mockData.feeStructure),\n+  payments: createCrudApi('fee-payment', mockData.feePayments),\n \n-                    getSummary: async() => {\n-                            await delay()\n-                            const totalStudents = mockData.students.filter(\n-                                s => s.status === 'active'\n-                            ).length\n-                            const totalFeeAmount = totalStudents * 5000 // Assuming 5000 per month\n+  getSummary: async () => {\n+    await delay()\n+    const totalStudents = mockData.students.filter(\n+      s => s.status === 'active'\n+    ).length\n+    const totalFeeAmount = totalStudents * 5000 // Assuming 5000 per month\n \n-                            const paidPayments = mockData.feePayments.filter(p => p.status === 'paid')\n-                            const totalPaid = paidPayments.reduce(\n-                                (sum, payment) => sum + payment.amount,\n-                                0\n+    const paidPayments = mockData.feePayments.filter(p => p.status === 'paid')\n+    const totalPaid = paidPayments.reduce(\n+      (sum, payment) => sum + payment.amount,\n+      0\n+    )\n \n-                                const pendingPayments = mockData.feePayments.filter(\n-                                    p => p.status === 'pending'\n-                                )\n-                                const totalPending = pendingPayments.reduce(\n-                                        (sum, payment) => sum + payment.amount,\n-                                        0\n+    const pendingPayments = mockData.feePayments.filter(\n+      p => p.status === 'pending'\n+    )\n+    const totalPending = pendingPayments.reduce(\n+      (sum, payment) => sum + payment.amount,\n+      0\n+    )\n \n-                                        return {\n-                                            totalAmount: totalFeeAmount,\n-                                            totalPaid,\n-                                            totalPending,\n-                                            collectionPercentage: totalFeeAmount > 0 ?\n-                                                ((totalPaid / totalFeeAmount) * 100).toFixed(1) :\n-                                                0,\n-                                            totalStudents,\n-                                            paidStudents: new Set(paidPayments.map(p => p.studentId)).size,\n-                                            pendingStudents: new Set(pendingPayments.map(p => p.studentId)).size,\n-                                        }\n-                                    },\n+    return {\n+      totalAmount: totalFeeAmount,\n+      totalPaid,\n+      totalPending,\n+      collectionPercentage: totalFeeAmount > 0 ?\n+        ((totalPaid / totalFeeAmount) * 100).toFixed(1) : 0,\n+      totalStudents,\n+      paidStudents: new Set(paidPayments.map(p => p.studentId)).size,\n+      pendingStudents: new Set(pendingPayments.map(p => p.studentId)).size,\n+    }\n+  },\n \n-                                    getStudentFees: async studentId => {\n-                                        await delay()\n-                                        const payments = mockData.feePayments.filter(p => p.studentId === studentId)\n-                                        const student = mockData.students.find(s => s.id === studentId)\n+  getStudentFees: async studentId => {\n+    await delay()\n+    const payments = mockData.feePayments.filter(p => p.studentId === studentId)\n+    const student = mockData.students.find(s => s.id === studentId)\n \n-                                        if (!student) {\n-                                            throw createError(404, 'Student not found')\n-                                        }\n+    if (!student) {\n+      throw createError(404, 'Student not found')\n+    }\n \n-                                        return {\n-                                            student,\n-                                            payments,\n-                                            totalPaid: payments\n-                                                .filter(p => p.status === 'paid')\n-                                                .reduce((sum, p) => sum + p.amount, 0),\n-                                            totalPending: payments\n-                                                .filter(p => p.status === 'pending')\n-                                                .reduce((sum, p) => sum + p.amount, 0),\n-                                        }\n-                                    },\n+    return {\n+      student,\n\\ No newline at end of file\n+      payments,\n+      totalPaid: payments\n+        .filter(p => p.status === 'paid')\n+        .reduce((sum, p) => sum + p.amount, 0),\n+      totalPending: payments\n+        .filter(p => p.status === 'pending')\n+        .reduce((sum, p) => sum + p.amount, 0),\n+    }\n+  },\n \n-                                    recordPayment: async paymentData => {\n-                                        await delay()\n-                                        if (shouldSimulateError()) {\n-                                            throw createError(500, 'Failed to record payment')\n-                                        }\n+  recordPayment: async paymentData => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, 'Failed to record payment')\n+    }\n \n-                                        const payment = {\n-                                            id: `payment-${Date.now()}`,\n-                                            ...paymentData,\n-                                            transactionId: `TXN${Date.now()}`,\n-                                            status: 'paid',\n-                                            createdAt: new Date().toISOString(),\n-                                        }\n+    const payment = {\n+      id: `payment-${Date.now()}`,\n+      ...paymentData,\n+      transactionId: `TXN${Date.now()}`,\n+      status: 'paid',\n+      createdAt: new Date().toISOString(),\n+    }\n \n-                                        mockData.feePayments.push(payment)\n-                                        return payment\n-                                    },\n-                            }\n+    mockData.feePayments.push(payment)\n+    return payment\n+  },\n+}\n \n-                            // Notices API\n-                            export const noticesApi = {\n-                                ...createCrudApi('notice', mockData.notices),\n+// Notices API\n+export const noticesApi = {\n+  ...createCrudApi('notice', mockData.notices),\n \n-                                getByAudience: async audience => {\n-                                    await delay()\n-                                    return mockData.notices.filter(\n-                                        notice =>\n-                                        notice.targetAudience.includes(audience) &&\n-                                        notice.status === 'published' &&\n-                                        new Date(notice.validUntil) > new Date(),\n-                                    )\n-                                },\n-                            }\n+  getByAudience: async audience => {\n+    await delay()\n+    return mockData.notices.filter(\n+      notice =>\n+        notice.targetAudience.includes(audience) &&\n+        notice.status === 'published' &&\n+        new Date(notice.validUntil) > new Date(),\n+    )\n+  },\n+}\n \n-                            // Homework API\n-                            export const homeworkApi = {\n-                                    homework: createCrudApi('homework', mockData.homework),\n-                                    submissions: createCrudApi(\n-                                        'homework-submission',\n-                                        mockData.homeworkSubmissions\n+// Homework API\n+export const homeworkApi = {\n+  homework: createCrudApi('homework', mockData.homework),\n+  submissions: createCrudApi(\n+    'homework-submission',\n+    mockData.homeworkSubmissions\n+  ),\n \n-                                        getByClass: async(classId, section) => {\n-                                            await delay()\n-                                            return mockData.homework.filter(\n-                                                hw => hw.classId === classId && hw.section === section,\n-                                            )\n-                                        },\n+  getByClass: async (classId, section) => {\n+    await delay()\n+    return mockData.homework.filter(\n+      hw => hw.classId === classId && hw.section === section,\n+    )\n+  },\n \n-                                        getStudentHomework: async studentId => {\n-                                            await delay()\n-                                            const student = mockData.students.find(s => s.id === studentId)\n-                                            if (!student) {\n-                                                throw createError(404, 'Student not found')\n-                                            }\n+  getStudentHomework: async studentId => {\n+    await delay()\n+    const student = mockData.students.find(s => s.id === studentId)\n+    if (!student) {\n+      throw createError(404, 'Student not found')\n+    }\n \n-                                            const homework = mockData.homework.filter(\n-                                                hw => hw.classId === student.classId && hw.section === student.section,\n-                                            )\n+    const homework = mockData.homework.filter(\n+      hw => hw.classId === student.classId && hw.section === student.section,\n+    )\n \n-                                            return homework.map(hw => {\n-                                                const submission = mockData.homeworkSubmissions.find(\n-                                                    sub => sub.homeworkId === hw.id && sub.studentId === studentId,\n-                                                )\n+    return homework.map(hw => {\n+      const submission = mockData.homeworkSubmissions.find(\n+        sub => sub.homeworkId === hw.id && sub.studentId === studentId,\n+      )\n \n-                                                return {\n-                                                    ...hw,\n-                                                    submission,\n-                                                    status: submission ? submission.status : 'pending',\n-                                                }\n-                                            })\n-                                        },\n+      return {\n+        ...hw,\n+        submission,\n+        status: submission ? submission.status : 'pending',\n+      }\n+    })\n+  },\n \n-                                        submitHomework: async submissionData => {\n-                                            await delay()\n-                                            if (shouldSimulateError()) {\n-                                                throw createError(500, 'Failed to submit homework')\n-                                            }\n+  submitHomework: async submissionData => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, 'Failed to submit homework')\n+    }\n \n-                                            const submission = {\n-                                                id: `sub-${Date.now()}`,\n-                                                ...submissionData,\n-                                                submittedAt: new Date().toISOString(),\n-                                                status: 'submitted',\n-                                            }\n+    const submission = {\n+      id: `sub-${Date.now()}`,\n+      ...submissionData,\n+      submittedAt: new Date().toISOString(),\n+      status: 'submitted',\n+    }\n \n-                                            mockData.homeworkSubmissions.push(submission)\n-                                            return submission\n-                                        },\n-                                    }\n+    mockData.homeworkSubmissions.push(submission)\n+    return submission\n+  },\n+}\n \n-                                    // Admissions API\n-                                        export const admissionsApi = {\n-                                        ...createCrudApi('admission', mockData.admissions),\n+// Admissions API\n+export const admissionsApi = {\n+  ...createCrudApi('admission', mockData.admissions),\n \n-                                        processApplication: async(id, status, remarks) => {\n-                                            await delay()\n-                                            if (shouldSimulateError()) {\n-                                                throw createError(500, 'Failed to process application')\n-                                            }\n+  processApplication: async (id, status, remarks) => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, 'Failed to process application')\n+    }\n \n-                                            const index = mockData.admissions.findIndex(app => app.id === id)\n-                                            if (index === -1) {\n-                                                throw createError(404, 'Application not found')\n-                                            }\n+    const index = mockData.admissions.findIndex(app => app.id === id)\n+    if (index === -1) {\n+      throw createError(404, 'Application not found')\n+    }\n \n-                                            mockData.admissions[index] = {\n-                                                ...mockData.admissions[index],\n-                                                status,\n-                                                remarks,\n-                                                processedBy: 'staff-1', // Current user\n-                                                processedAt: new Date().toISOString(),\n-                                            }\n+    mockData.admissions[index] = {\n+      ...mockData.admissions[index],\n+      status,\n+      remarks,\n+      processedBy: 'staff-1', // Current user\n+      processedAt: new Date().toISOString(),\n+    }\n \n-                                            return mockData.admissions[index]\n-                                        },\n-                                    }\n+    return mockData.admissions[index]\n+  },\n+}\n \n-                                    // Leave Requests API\n-                                        export const leaveRequestsApi = {\n-                                        ...createCrudApi('leave-request', mockData.leaveRequests),\n+// Leave Requests API\n+export const leaveRequestsApi = {\n+  ...createCrudApi('leave-request', mockData.leaveRequests),\n \n-                                        getByUser: async userId => {\n-                                            await delay()\n-                                            return mockData.leaveRequests.filter(request => request.userId === userId)\n-                                        },\n+  getByUser: async userId => {\n+    await delay()\n+    return mockData.leaveRequests.filter(request => request.userId === userId)\n+  },\n \n-                                        approveRequest: async(id, remarks = '') => {\n-                                            await delay()\n-                                            if (shouldSimulateError()) {\n-                                                throw createError(500, 'Failed to approve leave request')\n-                                            }\n+  approveRequest: async (id, remarks = '') => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, 'Failed to approve leave request')\n+    }\n \n-                                            const index = mockData.leaveRequests.findIndex(req => req.id === id)\n-                                            if (index === -1) {\n-                                                throw createError(404, 'Leave request not found')\n-                                            }\n+    const index = mockData.leaveRequests.findIndex(req => req.id === id)\n+    if (index === -1) {\n+      throw createError(404, 'Leave request not found')\n+    }\n \n-                                            mockData.leaveRequests[index] = {\n-                                                ...mockData.leaveRequests[index],\n-                                                status: 'approved',\n-                                                remarks,\n-                                                approvedBy: 'staff-1', // Current user\n-                                                approvedAt: new Date().toISOString(),\n-                                            }\n+    mockData.leaveRequests[index] = {\n+      ...mockData.leaveRequests[index],\n+      status: 'approved',\n+      remarks,\n+      approvedBy: 'staff-1', // Current user\n+      approvedAt: new Date().toISOString(),\n+    }\n \n-                                            return mockData.leaveRequests[index]\n-                                        },\n+    return mockData.leaveRequests[index]\n+  },\n \n-                                        rejectRequest: async(id, remarks = '') => {\n-                                            await delay()\n-                                            if (shouldSimulateError()) {\n-                                                throw createError(500, 'Failed to reject leave request')\n-                                            }\n+  rejectRequest: async (id, remarks = '') => {\n+    await delay()\n+    if (shouldSimulateError()) {\n+      throw createError(500, 'Failed to reject leave request')\n+    }\n \n-                                            const index = mockData.leaveRequests.findIndex(req => req.id === id)\n-                                            if (index === -1) {\n-                                                throw createError(404, 'Leave request not found')\n-                                            }\n+    const index = mockData.leaveRequests.findIndex(req => req.id === id)\n+    if (index === -1) {\n+      throw createError(404, 'Leave request not found')\n+    }\n \n-                                            mockData.leaveRequests[index] = {\n-                                                ...mockData.leaveRequests[index],\n-                                                status: 'rejected',\n-                                                remarks,\n-                                                approvedBy: 'staff-1', // Current user\n-                                                approvedAt: new Date().toISOString(),\n-                                            }\n+    mockData.leaveRequests[index] = {\n+      ...mockData.leaveRequests[index],\n+      status: 'rejected',\n+      remarks,\n+      approvedBy: 'staff-1', // Current user\n+      approvedAt: new Date().toISOString(),\n+    }\n \n-                                            return mockData.leaveRequests[index]\n-                                        },\n-                                    }\n+    return mockData.leaveRequests[index]\n+  },\n+}\n \n-                                    // Dashboard API\n-                                        export const dashboardApi = {\n-                                        getKpis: async role => {\n-                                            await delay()\n+// Dashboard API\n+export const dashboardApi = {\n+  getKpis: async role => {\n+    await delay()\n \n-                                            const today = new Date().toISOString().split('T')[0]\n-                                            const attendanceToday = await attendanceApi.getTodayAttendance()\n+    const today = new Date().toISOString().split('T')[0]\n+    const attendanceToday = await attendanceApi.getTodayAttendance()\n \n-                                            switch (role) {\n-                                                case 'admin':\n-                                                    return {\n-                                                        totalUsers: mockData.students.length + mockData.staff.length,\n-                                                        totalStudents: mockData.students.filter(s => s.status === 'active')\n-                                                            .length,\n-                                                        totalStaff: mockData.staff.filter(s => s.status === 'active').length,\n-                                                        totalClasses: mockData.classes.length,\n-                                                        attendanceRate: attendanceToday.students.percentage,\n-                                                        feeCollection: (await feesApi.getSummary()).collectionPercentage,\n-                                                    }\n+    switch (role) {\n+      case 'admin':\n+        return {\n+          totalUsers: mockData.students.length + mockData.staff.length,\n+          totalStudents: mockData.students.filter(s => s.status === 'active')\n+            .length,\n+          totalStaff: mockData.staff.filter(s => s.status === 'active').length,\n+          totalClasses: mockData.classes.length,\n+          attendanceRate: attendanceToday.students.percentage,\n+          feeCollection: (await feesApi.getSummary()).collectionPercentage,\n+        }\n \n-                                                case 'principal':\n-                                                    return {\n-                                                        totalStudents: mockData.students.filter(s => s.status === 'active')\n-                                                            .length,\n-                                                        totalTeachers: mockData.staff.filter(s => s.role === 'teacher')\n-                                                            .length,\n-                                                        attendanceRate: attendanceToday.students.percentage,\n-                                                        pendingAdmissions: mockData.admissions.filter(\n-                                                            a => a.status === 'pending'\n-                                                        ).length,\n-                                                    }\n+      case 'principal':\n+        return {\n+          totalStudents: mockData.students.filter(s => s.status === 'active')\n+            .length,\n+          totalTeachers: mockData.staff.filter(s => s.role === 'teacher')\n+            .length,\n+          attendanceRate: attendanceToday.students.percentage,\n+          pendingAdmissions: mockData.admissions.filter(\n+            a => a.status === 'pending'\n+          ).length,\n+        }\n \n-                                                case 'teacher':\n-                                                    // Assuming current teacher teaches certain classes\n-                                                    const teacherClasses = ['class-9', 'class-10']\n-                                                    const teacherStudents = mockData.students.filter(s =>\n-                                                        teacherClasses.includes(s.classId),\n-                                                    )\n-                                                    return {\n-                                                        totalStudents: teacherStudents.length,\n-                                                        totalClasses: teacherClasses.length,\n-                                                        pendingHomework: mockData.homework.filter(hw =>\n-                                                            teacherClasses.includes(hw.classId),\n-                                                        ).length,\n-                                                        upcomingExams: mockData.exams.filter(\n-                                                            exam => teacherClasses.includes(exam.classId) && exam.date >= today,\n-                                                        ).length,\n-                                                    }\n+      case 'teacher':\n+        // Assuming current teacher teaches certain classes\n+        const teacherClasses = ['class-9', 'class-10']\n+        const teacherStudents = mockData.students.filter(s =>\n+          teacherClasses.includes(s.classId),\n+        )\n+        return {\n+          totalStudents: teacherStudents.length,\n+          totalClasses: teacherClasses.length,\n+          pendingHomework: mockData.homework.filter(hw =>\n+            teacherClasses.includes(hw.classId),\n+          ).length,\n+          upcomingExams: mockData.exams.filter(\n+            exam => teacherClasses.includes(exam.classId) && exam.date >= today,\n+          ).length,\n+        }\n \n-                                                case 'student':\n-                                                    // Assuming current student\n-                                                    const currentStudent = mockData.students[0]\n-                                                    const studentHomework = await homeworkApi.getStudentHomework(\n-                                                        currentStudent.id\n-                                                    )\n-                                                    return {\n-                                                        totalSubjects: mockData.subjects.length,\n-                                                        pendingHomework: studentHomework.filter(hw => hw.status === 'pending')\n-                                                            .length,\n-                                                        upcomingExams: mockData.exams.filter(\n-                                                            exam =>\n-                                                            exam.classId === currentStudent.classId &&\n-                                                            exam.section === currentStudent.section &&\n-                                                            exam.date >= today,\n-                                                        ).length,\n-                                                        attendanceRate: 92.5, // Mock percentage\n-                                                    }\n+      case 'student':\n+        // Assuming current student\n+        const currentStudent = mockData.students[0]\n+        const studentHomework = await homeworkApi.getStudentHomework(\n+          currentStudent.id\n+        )\n+        return {\n+          totalSubjects: mockData.subjects.length,\n+          pendingHomework: studentHomework.filter(hw => hw.status === 'pending')\n+            .length,\n+          upcomingExams: mockData.exams.filter(\n+            exam =>\n+              exam.classId === currentStudent.classId &&\n+              exam.section === currentStudent.section &&\n+              exam.date >= today,\n+          ).length,\n+          attendanceRate: 92.5, // Mock percentage\n+        }\n \n-                                                case 'parent':\n-                                                    const parentChildren = mockData.students.slice(0, 2) // Mock 2 children\n-                                                    return {\n-                                                        totalChildren: parentChildren.length,\n-                                                        averageAttendance: 94.2,\n-                                                        pendingFees: 2,\n-                                                        upcomingEvents: 3,\n-                                                    }\n+      case 'parent':\n+        const parentChildren = mockData.students.slice(0, 2) // Mock 2 children\n+        return {\n+          totalChildren: parentChildren.length,\n+          averageAttendance: 94.2,\n+          pendingFees: 2,\n+          upcomingEvents: 3,\n+        }\n \n-                                                case 'accountant':\n-                                                    const feesSummary = await feesApi.getSummary()\n-                                                    return {\n-                                                        totalCollection: feesSummary.totalPaid,\n-                                                        pendingAmount: feesSummary.totalPending,\n-                                                        collectionRate: feesSummary.collectionPercentage,\n-                                                        totalTransactions: mockData.feePayments.length,\n-                                                    }\n+      case 'accountant':\n+        const feesSummary = await feesApi.getSummary()\n+        return {\n+          totalCollection: feesSummary.totalPaid,\n+          pendingAmount: feesSummary.totalPending,\n+          collectionRate: feesSummary.collectionPercentage,\n+          totalTransactions: mockData.feePayments.length,\n+        }\n \n-                                                default:\n-                                                    return {}\n-                                            }\n-                                        },\n-                                    }\n+      default:\n+        return {}\n+    }\n+  },\n+}\n \n-                                        export default {\n-                                        students: studentsApi,\n-                                        staff: staffApi,\n-                                        classes: classesApi,\n-                                        subjects: subjectsApi,\n-                                        attendance: attendanceApi,\n-                                        exams: examsApi,\n-                                        fees: feesApi,\n-                                        notices: noticesApi,\n-                                        homework: homeworkApi,\n-                                        admissions: admissionsApi,\n-                                        leaveRequests: leaveRequestsApi,\n-                                        dashboard: dashboardApi,\n-                                    }\n+export default {\n+  students: studentsApi,\n+  staff: staffApi,\n+  classes: classesApi,\n+  subjects: subjectsApi,\n+  attendance: attendanceApi,\n+  exams: examsApi,\n+  fees: feesApi,\n+  notices: noticesApi,\n+  homework: homeworkApi,\n+  admissions: admissionsApi,\n+  leaveRequests: leaveRequestsApi,\n+  dashboard: dashboardApi,\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1755987434757,
            "name": "Commit-0",
            "content": "import mockData from './mockData.js'\n\n// Simulate network latency\nconst delay = (ms = 500 + Math.random() * 1000) =>\n    new Promise(resolve => setTimeout(resolve, ms))\n\n// Simulate API errors occasionally\nconst shouldSimulateError = (errorRate = 0.05) => Math.random() < errorRate\n\nconst createError = (status, message) => {\n    const error = new Error(message)\n    error.status = status\n    return error\n}\n\n// Generic CRUD operations\nconst createCrudApi = (resourceName, data) => ({\n    getAll: async(filters = {}) => {\n        await delay()\n        if (shouldSimulateError()) {\n            throw createError(500, `Failed to fetch ${resourceName}`)\n        }\n\n        let result = [...data]\n\n        // Apply filters\n        Object.entries(filters).forEach(([key, value]) => {\n            if (value !== undefined && value !== null && value !== '') {\n                result = result.filter(item => {\n                    if (typeof item[key] === 'string') {\n                        return item[key].toLowerCase().includes(value.toLowerCase())\n                    }\n                    return item[key] === value\n                })\n            }\n        })\n\n        return result\n    },\n\n    getById: async id => {\n        await delay()\n        if (shouldSimulateError()) {\n            throw createError(500, `Failed to fetch ${resourceName}`)\n        }\n\n        const item = data.find(item => item.id === id)\n        if (!item) {\n            throw createError(404, `${resourceName} not found`)\n        }\n\n        return item\n    },\n\n    create: async newItem => {\n        await delay()\n        if (shouldSimulateError()) {\n            throw createError(500, `Failed to create ${resourceName}`)\n        }\n\n        const item = {\n            ...newItem,\n            id: `${resourceName}-${Date.now()}`,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n        }\n\n        data.push(item)\n        return item\n    },\n\n    update: async(id, updates) => {\n        await delay()\n        if (shouldSimulateError()) {\n            throw createError(500, `Failed to update ${resourceName}`)\n        }\n\n        const index = data.findIndex(item => item.id === id)\n        if (index === -1) {\n            throw createError(404, `${resourceName} not found`)\n        }\n\n        data[index] = {\n            ...data[index],\n            ...updates,\n            updatedAt: new Date().toISOString(),\n        }\n\n        return data[index]\n    },\n\n    delete: async id => {\n        await delay()\n        if (shouldSimulateError()) {\n            throw createError(500, `Failed to delete ${resourceName}`)\n        }\n\n        const index = data.findIndex(item => item.id === id)\n        if (index === -1) {\n            throw createError(404, `${resourceName} not found`)\n        }\n\n        const deleted = data.splice(index, 1)[0]\n        return deleted\n    },\n})\n\n// Students API\nexport const studentsApi = {\n    ...createCrudApi('student', mockData.students),\n\n    getByClass: async(classId, section) => {\n        await delay()\n        if (shouldSimulateError()) {\n            throw createError(500, 'Failed to fetch students by class')\n        }\n\n        return mockData.students.filter(\n            student =>\n            student.classId === classId && (!section || student.section === section),\n        )\n    },\n\n    getByParent: async parentEmail => {\n        await delay()\n        return mockData.students.filter(\n            student => student.parentEmail === parentEmail,\n        )\n    },\n}\n\n// Staff API\nexport const staffApi = {\n    ...createCrudApi('staff', mockData.staff),\n\n    getTeachers: async() => {\n        await delay()\n        return mockData.staff.filter(member => member.role === 'teacher')\n    },\n\n    getByDepartment: async department => {\n        await delay()\n        return mockData.staff.filter(member => member.department === department)\n    },\n}\n\n// Classes API\nexport const classesApi = {\n    ...createCrudApi('class', mockData.classes),\n\n    getSections: async classId => {\n        await delay()\n        const classData = mockData.classes.find(c => c.id === classId)\n        if (!classData) {\n            throw createError(404, 'Class not found')\n        }\n\n        return classData.sections.map(section => ({\n            id: `${classId}-${section}`,\n            name: section,\n            classId,\n            students: mockData.students.filter(\n                s => s.classId === classId && s.section === section,\n            ).length,\n        }))\n    },\n}\n\n// Subjects API\nexport const subjectsApi = createCrudApi('subject', mockData.subjects)\n\n// Attendance API\nexport const attendanceApi = {\n    ...createCrudApi('attendance', mockData.attendance),\n\n    getByUser: async(userId, dateRange = {}) => {\n        await delay()\n        let records = mockData.attendance.filter(record => record.userId === userId)\n\n        if (dateRange.start) {\n            records = records.filter(record => record.date >= dateRange.start)\n        }\n        if (dateRange.end) {\n            records = records.filter(record => record.date <= dateRange.end)\n        }\n\n        return records\n    },\n\n    getByClass: async(classId, section, date) => {\n        await delay()\n        const students = mockData.students.filter(\n            s => s.classId === classId && s.section === section,\n        )\n\n        const attendanceRecords = mockData.attendance.filter(\n            record => record.date === date && record.type === 'student',\n        )\n\n        return students.map(student => {\n            const record = attendanceRecords.find(r => r.userId === student.id)\n            return {\n                student,\n                attendance: record || {\n                    status: 'not_marked',\n                    date,\n                    userId: student.id,\n                },\n            }\n        })\n    },\n\n    getTodayAttendance: async() => {\n        await delay()\n        const today = new Date().toISOString().split('T')[0]\n\n        const studentAttendance = mockData.attendance.filter(\n            record => record.date === today && record.type === 'student',\n        )\n\n        const staffAttendance = mockData.attendance.filter(\n            record => record.date === today && record.type === 'staff',\n        )\n\n        const totalStudents = mockData.students.filter(\n            s => s.status === 'active'\n        ).length\n        const totalStaff = mockData.staff.filter(s => s.status === 'active').length\n\n        const presentStudents = studentAttendance.filter(\n            r => r.status === 'present'\n        ).length\n        const presentStaff = staffAttendance.filter(\n            r => r.status === 'present'\n        ).length\n\n        return {\n            students: {\n                total: totalStudents,\n                present: presentStudents,\n                absent: totalStudents - presentStudents,\n                percentage: totalStudents > 0 ?\n                    ((presentStudents / totalStudents) * 100).toFixed(1) :\n                    0,\n            },\n            staff: {\n                total: totalStaff,\n                present: presentStaff,\n                absent: totalStaff - presentStaff,\n                percentage: totalStaff > 0 ? ((presentStaff / totalStaff) * 100).toFixed(1) : 0,\n            },\n        }\n    },\n\n    markAttendance: async attendanceData => {\n        await delay()\n        if (shouldSimulateError()) {\n            throw createError(500, 'Failed to mark attendance')\n        }\n\n        const records = attendanceData.map(data => ({\n            id: `att-${data.userId}-${data.date}`,\n            ...data,\n            markedAt: new Date().toISOString(),\n        }))\n\n        // Remove existing records for the same date and users\n        mockData.attendance = mockData.attendance.filter(\n            record =>\n            !attendanceData.some(\n                data => data.userId === record.userId && data.date === record.date,\n            )\n        )\n\n        mockData.attendance.push(...records)\n        return records\n    },\n}\n\n// Exams API\nexport const examsApi = {\n        ...createCrudApi('exam', mockData.exams),\n\n        getSchedule: async(classId, section) => {\n            await delay()\n            return mockData.exams.filter(\n                exam => exam.classId === classId &&\n                (!section || exam.section === section),\n            )\n        },\n\n        getResults: async(examId, studentId) => {\n            await delay()\n            let results = mockData.examResults.filter(\n                    result => result.examId === examId\n\n                    if (studentId) {\n                        results = results.filter(result => result.studentId === studentId)\n                    }\n\n                    return results\n                },\n\n                submitResult: async resultData => {\n                    await delay()\n                    if (shouldSimulateError()) {\n                        throw createError(500, 'Failed to submit result')\n                    }\n\n                    const result = {\n                        id: `result-${Date.now()}`,\n                        ...resultData,\n                        evaluatedAt: new Date().toISOString(),\n                    }\n\n                    mockData.examResults.push(result)\n                    return result\n                },\n        }\n\n        // Fees API\n            export const feesApi = {\n                    feeStructure: createCrudApi('fee-structure', mockData.feeStructure),\n                    payments: createCrudApi('fee-payment', mockData.feePayments),\n\n                    getSummary: async() => {\n                            await delay()\n                            const totalStudents = mockData.students.filter(\n                                s => s.status === 'active'\n                            ).length\n                            const totalFeeAmount = totalStudents * 5000 // Assuming 5000 per month\n\n                            const paidPayments = mockData.feePayments.filter(p => p.status === 'paid')\n                            const totalPaid = paidPayments.reduce(\n                                (sum, payment) => sum + payment.amount,\n                                0\n\n                                const pendingPayments = mockData.feePayments.filter(\n                                    p => p.status === 'pending'\n                                )\n                                const totalPending = pendingPayments.reduce(\n                                        (sum, payment) => sum + payment.amount,\n                                        0\n\n                                        return {\n                                            totalAmount: totalFeeAmount,\n                                            totalPaid,\n                                            totalPending,\n                                            collectionPercentage: totalFeeAmount > 0 ?\n                                                ((totalPaid / totalFeeAmount) * 100).toFixed(1) :\n                                                0,\n                                            totalStudents,\n                                            paidStudents: new Set(paidPayments.map(p => p.studentId)).size,\n                                            pendingStudents: new Set(pendingPayments.map(p => p.studentId)).size,\n                                        }\n                                    },\n\n                                    getStudentFees: async studentId => {\n                                        await delay()\n                                        const payments = mockData.feePayments.filter(p => p.studentId === studentId)\n                                        const student = mockData.students.find(s => s.id === studentId)\n\n                                        if (!student) {\n                                            throw createError(404, 'Student not found')\n                                        }\n\n                                        return {\n                                            student,\n                                            payments,\n                                            totalPaid: payments\n                                                .filter(p => p.status === 'paid')\n                                                .reduce((sum, p) => sum + p.amount, 0),\n                                            totalPending: payments\n                                                .filter(p => p.status === 'pending')\n                                                .reduce((sum, p) => sum + p.amount, 0),\n                                        }\n                                    },\n\n                                    recordPayment: async paymentData => {\n                                        await delay()\n                                        if (shouldSimulateError()) {\n                                            throw createError(500, 'Failed to record payment')\n                                        }\n\n                                        const payment = {\n                                            id: `payment-${Date.now()}`,\n                                            ...paymentData,\n                                            transactionId: `TXN${Date.now()}`,\n                                            status: 'paid',\n                                            createdAt: new Date().toISOString(),\n                                        }\n\n                                        mockData.feePayments.push(payment)\n                                        return payment\n                                    },\n                            }\n\n                            // Notices API\n                            export const noticesApi = {\n                                ...createCrudApi('notice', mockData.notices),\n\n                                getByAudience: async audience => {\n                                    await delay()\n                                    return mockData.notices.filter(\n                                        notice =>\n                                        notice.targetAudience.includes(audience) &&\n                                        notice.status === 'published' &&\n                                        new Date(notice.validUntil) > new Date(),\n                                    )\n                                },\n                            }\n\n                            // Homework API\n                            export const homeworkApi = {\n                                    homework: createCrudApi('homework', mockData.homework),\n                                    submissions: createCrudApi(\n                                        'homework-submission',\n                                        mockData.homeworkSubmissions\n\n                                        getByClass: async(classId, section) => {\n                                            await delay()\n                                            return mockData.homework.filter(\n                                                hw => hw.classId === classId && hw.section === section,\n                                            )\n                                        },\n\n                                        getStudentHomework: async studentId => {\n                                            await delay()\n                                            const student = mockData.students.find(s => s.id === studentId)\n                                            if (!student) {\n                                                throw createError(404, 'Student not found')\n                                            }\n\n                                            const homework = mockData.homework.filter(\n                                                hw => hw.classId === student.classId && hw.section === student.section,\n                                            )\n\n                                            return homework.map(hw => {\n                                                const submission = mockData.homeworkSubmissions.find(\n                                                    sub => sub.homeworkId === hw.id && sub.studentId === studentId,\n                                                )\n\n                                                return {\n                                                    ...hw,\n                                                    submission,\n                                                    status: submission ? submission.status : 'pending',\n                                                }\n                                            })\n                                        },\n\n                                        submitHomework: async submissionData => {\n                                            await delay()\n                                            if (shouldSimulateError()) {\n                                                throw createError(500, 'Failed to submit homework')\n                                            }\n\n                                            const submission = {\n                                                id: `sub-${Date.now()}`,\n                                                ...submissionData,\n                                                submittedAt: new Date().toISOString(),\n                                                status: 'submitted',\n                                            }\n\n                                            mockData.homeworkSubmissions.push(submission)\n                                            return submission\n                                        },\n                                    }\n\n                                    // Admissions API\n                                        export const admissionsApi = {\n                                        ...createCrudApi('admission', mockData.admissions),\n\n                                        processApplication: async(id, status, remarks) => {\n                                            await delay()\n                                            if (shouldSimulateError()) {\n                                                throw createError(500, 'Failed to process application')\n                                            }\n\n                                            const index = mockData.admissions.findIndex(app => app.id === id)\n                                            if (index === -1) {\n                                                throw createError(404, 'Application not found')\n                                            }\n\n                                            mockData.admissions[index] = {\n                                                ...mockData.admissions[index],\n                                                status,\n                                                remarks,\n                                                processedBy: 'staff-1', // Current user\n                                                processedAt: new Date().toISOString(),\n                                            }\n\n                                            return mockData.admissions[index]\n                                        },\n                                    }\n\n                                    // Leave Requests API\n                                        export const leaveRequestsApi = {\n                                        ...createCrudApi('leave-request', mockData.leaveRequests),\n\n                                        getByUser: async userId => {\n                                            await delay()\n                                            return mockData.leaveRequests.filter(request => request.userId === userId)\n                                        },\n\n                                        approveRequest: async(id, remarks = '') => {\n                                            await delay()\n                                            if (shouldSimulateError()) {\n                                                throw createError(500, 'Failed to approve leave request')\n                                            }\n\n                                            const index = mockData.leaveRequests.findIndex(req => req.id === id)\n                                            if (index === -1) {\n                                                throw createError(404, 'Leave request not found')\n                                            }\n\n                                            mockData.leaveRequests[index] = {\n                                                ...mockData.leaveRequests[index],\n                                                status: 'approved',\n                                                remarks,\n                                                approvedBy: 'staff-1', // Current user\n                                                approvedAt: new Date().toISOString(),\n                                            }\n\n                                            return mockData.leaveRequests[index]\n                                        },\n\n                                        rejectRequest: async(id, remarks = '') => {\n                                            await delay()\n                                            if (shouldSimulateError()) {\n                                                throw createError(500, 'Failed to reject leave request')\n                                            }\n\n                                            const index = mockData.leaveRequests.findIndex(req => req.id === id)\n                                            if (index === -1) {\n                                                throw createError(404, 'Leave request not found')\n                                            }\n\n                                            mockData.leaveRequests[index] = {\n                                                ...mockData.leaveRequests[index],\n                                                status: 'rejected',\n                                                remarks,\n                                                approvedBy: 'staff-1', // Current user\n                                                approvedAt: new Date().toISOString(),\n                                            }\n\n                                            return mockData.leaveRequests[index]\n                                        },\n                                    }\n\n                                    // Dashboard API\n                                        export const dashboardApi = {\n                                        getKpis: async role => {\n                                            await delay()\n\n                                            const today = new Date().toISOString().split('T')[0]\n                                            const attendanceToday = await attendanceApi.getTodayAttendance()\n\n                                            switch (role) {\n                                                case 'admin':\n                                                    return {\n                                                        totalUsers: mockData.students.length + mockData.staff.length,\n                                                        totalStudents: mockData.students.filter(s => s.status === 'active')\n                                                            .length,\n                                                        totalStaff: mockData.staff.filter(s => s.status === 'active').length,\n                                                        totalClasses: mockData.classes.length,\n                                                        attendanceRate: attendanceToday.students.percentage,\n                                                        feeCollection: (await feesApi.getSummary()).collectionPercentage,\n                                                    }\n\n                                                case 'principal':\n                                                    return {\n                                                        totalStudents: mockData.students.filter(s => s.status === 'active')\n                                                            .length,\n                                                        totalTeachers: mockData.staff.filter(s => s.role === 'teacher')\n                                                            .length,\n                                                        attendanceRate: attendanceToday.students.percentage,\n                                                        pendingAdmissions: mockData.admissions.filter(\n                                                            a => a.status === 'pending'\n                                                        ).length,\n                                                    }\n\n                                                case 'teacher':\n                                                    // Assuming current teacher teaches certain classes\n                                                    const teacherClasses = ['class-9', 'class-10']\n                                                    const teacherStudents = mockData.students.filter(s =>\n                                                        teacherClasses.includes(s.classId),\n                                                    )\n                                                    return {\n                                                        totalStudents: teacherStudents.length,\n                                                        totalClasses: teacherClasses.length,\n                                                        pendingHomework: mockData.homework.filter(hw =>\n                                                            teacherClasses.includes(hw.classId),\n                                                        ).length,\n                                                        upcomingExams: mockData.exams.filter(\n                                                            exam => teacherClasses.includes(exam.classId) && exam.date >= today,\n                                                        ).length,\n                                                    }\n\n                                                case 'student':\n                                                    // Assuming current student\n                                                    const currentStudent = mockData.students[0]\n                                                    const studentHomework = await homeworkApi.getStudentHomework(\n                                                        currentStudent.id\n                                                    )\n                                                    return {\n                                                        totalSubjects: mockData.subjects.length,\n                                                        pendingHomework: studentHomework.filter(hw => hw.status === 'pending')\n                                                            .length,\n                                                        upcomingExams: mockData.exams.filter(\n                                                            exam =>\n                                                            exam.classId === currentStudent.classId &&\n                                                            exam.section === currentStudent.section &&\n                                                            exam.date >= today,\n                                                        ).length,\n                                                        attendanceRate: 92.5, // Mock percentage\n                                                    }\n\n                                                case 'parent':\n                                                    const parentChildren = mockData.students.slice(0, 2) // Mock 2 children\n                                                    return {\n                                                        totalChildren: parentChildren.length,\n                                                        averageAttendance: 94.2,\n                                                        pendingFees: 2,\n                                                        upcomingEvents: 3,\n                                                    }\n\n                                                case 'accountant':\n                                                    const feesSummary = await feesApi.getSummary()\n                                                    return {\n                                                        totalCollection: feesSummary.totalPaid,\n                                                        pendingAmount: feesSummary.totalPending,\n                                                        collectionRate: feesSummary.collectionPercentage,\n                                                        totalTransactions: mockData.feePayments.length,\n                                                    }\n\n                                                default:\n                                                    return {}\n                                            }\n                                        },\n                                    }\n\n                                        export default {\n                                        students: studentsApi,\n                                        staff: staffApi,\n                                        classes: classesApi,\n                                        subjects: subjectsApi,\n                                        attendance: attendanceApi,\n                                        exams: examsApi,\n                                        fees: feesApi,\n                                        notices: noticesApi,\n                                        homework: homeworkApi,\n                                        admissions: admissionsApi,\n                                        leaveRequests: leaveRequestsApi,\n                                        dashboard: dashboardApi,\n                                    }"
        }
    ]
}